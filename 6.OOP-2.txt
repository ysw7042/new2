● 클래스의 관계

  - 일반화 관계(Generalization) 

    >> 상속관계 : is a 관계 
  
    >> 부모클래스를 상속 받아 자식클래스에서 사용

    ex) 사원클래스     관리자클래스
  
        >> 관리자는 사원이다. (O)

        >> 사원은 관리자다.   (X)

  - 실체화 관계(Realization)

    >> 인터페이스를 상속 받아 자식클래스에서 재정의하여 사용

    ex) 도형 인터페이스 >> 원클래스  or  삼각형클래스

  - 연관 관계(Association) 또는 직접 연관 관계(Direct Association)

    >> 포함관계 : has a 관계
  
    >> 클래스 안에 필드를 참조변수로 선언하여 사용 - 인스턴스 정보 저장
    
    ex) Computer  <<  CPU + Mainboard + Memory 

  - 집합 연관 관계(Aggregation) 

    >> UML2.0에서는 연관관계로 표현 

    >> 포함 관계의 인스턴스와 생명주기 다른 경우

    ex)  컴퓨터 << 프린터

  - 복합 연관 관계(Compostion) 

    >> 포함 관계의 인스턴스와 생명주기 같은 경우

    ex)  게임  <<  캐릭터

  - 의존 관계(Dependency)

    >> 메소드의 파라메터로 선언되어 사용되는 참조변수

    >> 일시적으로 메소드에서 인스턴스를 사용할 경우

    ex)  TV   <<   리모콘

 ※ ObjectAid 설치(이클립스의 확장 프로그램) >> https://www.objectaid.com


● 상속(Inheritance) : 클래스를 물려받아 사용하는 기능
  
  - 상속을 사용하는 이유
  
    >> 기존 클래스를 활용하여 보다 빠르게 새로운 클래스 작성 : 프로그램의 생산성 증가

     ex) 자료실 => 게시판(상속) + 파일처리

    >> 공통적인 속성과 기능을 정의한 클래스를 생성하여 상속 받아 사용 : 유지보수 효율성 증가

      ex) 사람 >> 학생,강사,직원
  
  - 물려주는 클래스 : 부모클래스, 선조클래스, 슈퍼클래스, 기본클래스
  
    물려받는 클래스 : 자식클래스, 후손클래스, 서브클래스, 파생클래스
    
  - 부모클래스의 생성자는 자식클래스에게 상속 불가능

  - 부모클래스의 은닉화 선언된 필드 또는 메소드는 상속 되지만 접근 불가능
  
  - 상속 방법 : 단일 상속 >> 부모클래스가 하나만 존재
  
    public class 자식클래스 extends 부모클래스 {
        //부모클래스의 필드 및 메소드 사용 가능
    }
    
  - 자식클래스로 인스턴스를 생성할 경우 자식클래스의 생성자가 실행되기 전에 부모클래스 생성자가 먼저 실행  

    >> 부모 인스턴스 생성 후 자식 인스턴스 생성


● super 키워드

  - 자식클래스의 메소드에서 부모 인스턴스를 표현할 때 사용하는 키워드
  
    >> 자식클래스의 메소드에서 부모 인스턴스의 필드 또는 메소드에 접근하기 위해 사용

    >> 자식클래스의 필드 또는 메소드가 아닌 경우 자동으로 부모클래스의 필드 또는 메소드 사용 : super 생략 가능
    
  - super 키워드를 사용하는 경우
  
    1) 자식클래스의 생성자에서 부모클래스 생성자를 호출하기 위해 사용

     >> 자식클래스의 생성자가 호출되기 전에 super 키워드에 의해 부모클래스의 생성자가 먼저 호출

     >> super 키워드로 생성자 호출하는 명령은 생성자에서 최초의 명령으로 반드시 작성 

     >> super 키워드로 부모클래스의 생성자 호출이 생략된 경우 기본 생성자 호출
    
     형식) super(값,...);  
       
    2) 오버라이드 선언되어 숨겨진 부모클래스의 메소드에 직접 접근해야 할 경우 사용
    
     형식) super.메소드명(값,...); 


● 메소드 오버라이드(Method Override) : 상속관계에서만 구현 가능

  - 부모클래스의 메소드를 자식클래스에서 재선언 하는 기능

  - 자식클래스에서 메소드를 오버라이드 선언한 경우 부모클래스의 메소드는 
    숨겨지고 자식클래스의 메소드만 사용
  
  - 부모클래스의 메소드의 머릿부를 동일하게 선언
  
    >> 접근지정자, 반환형, 메소드명, 파라메터, 예외전달이 반드시 동일

      
● 상속 관계에서 참조변수(레퍼런스변수)와 인스턴스의 사용법

  1. 부모클래스 참조변수=new 부모클래스();//가능
 
     >> 참조변수는 부모클래스 요소에 접근 가능
 
  2. 자식클래스 참조변수=new 자식클래스();//가능
  
     >> 참조변수는 자식클래스의 요소 및 부모클래스의 요소에 접근 가능
     
  3. 자식클래스 참조변수=new 부모클래스();//불가능(에러)

     >> 자식인스턴스가 존재하지 않아 참조변수에 저장할 경우 에러 발생
     
  4. 부모클래스 참조변수=new 자식클래스();
  
     >> 참조변수는 기본적으로 부모클래스의 요소에 접근 가능
     
     >> 객체 형변환을 이용하면 자식클래스의 요소에 접근 가능
     
  - 객체 형변환 : 상속관계의 클래스에서 구현
  
    1) 명시적 형변환(강제형변환) >> cast 연산자 이용
    
       (자식클래스명)참조변수  >> 참조변수의 자료형을 상속관계의 자식클래스로 잠시 변환 
    
    2) 묵시적 형변환(자동형변환) >> 메소드 오버라이딩을 이용
    
  - 메소드 오버라이드에 의한 다형성

    >> 부모참조변수에 저장된 자식인스턴스에 따라 자식인스턴스의 메소드 호출

    >> 부모참조변수에 저장된 자식인스턴스를 JVM이 자동으로 구분하여 처리
    
  - instanceof 연산자
  
    >> 부모참조변수로 객체 형변환 가능한 자식인스턴스을 구분하기 위한 연산자
    
    형식) 참조변수 instanceof 자식클래스   

    >> 참조변수가 자식클래스로 객체 형변환 가능한 경우 true 제공


● java.lang.Objetc 클래스

  - 모든 클래스가 반드시 상속 받는 최선조클래스
  
    >> 모든 인스턴스는 Object 클래스의 메소드 사용 가능
   
  - 클래스를 선언할 때 상속받는 클래스가 없을 경우 자동으로 Object 클래스 상속
  
  - 참조변수의 인스턴스 정보를 출력하면 Object 클래스의 toString() 메소드 자동 호출

    >> Object 클래스의 toString() 메소드를 오버라이드 선언하여 사용

    
● final 키워드

 1. final 필드
 
   형식) 접근지정자 final 자료형 필드명=값;
   
   - 필드값 변경 불가능
   
   ※ final 필드명은 모두 대문자로 작성하며 단어 구분자로 _ 사용

   ※ 상수필드(Constant Field) : 값 대신 사용하기 위한 고유명칭 

      형식) public static final 필드명=값;
   
   ex) java.lang.Math 클래스 - public static final double PI
      
       >> API 문서에서 Constant Field Values 에서 저장된 값 확인
       
 2. final 메소드
 
   형식) 접근지정자 final 반환형 메소드명(파라메터,...) {
		명령;
		...
         }    
         
   - 메소드 오버라이드 선언 불가능
  
   ex) java.lang.Object 클래스 - public final void notify() 메소드
  
 3. final 클래스
 
   형식) 접근지정자 final class 클래스명 { }
   
   - 상속 불가능 >> 부모클래스로 사용 불가능
   
   ex) java.lang.System 클래스 - public final class System extends Object 
  

● 추상클래스(Abstract Class)

  - 추상클래스 선언
  
    형식) 접근지정자 abstract class 클래스명 { }
    
  - 추상클래스는 인스턴스 생성 불가능 >> 상속 목적의 클래스
  
  - 추상메소드를 1개라도 가지고 있으면 반드시 추상클래스 선언

  - 추상메소드 >> 영역이 없는 불완전한 메소드 : 명령 미존재
  
    형식) 접근지정자 abstract 반환명 메소드명(파라메터,...);
    
  - 추상메소드가 존재하는 추상클래스를 상속받은 자식클래스는 모든 추상메소드를 반드시 오버라이드 선언

    >> 추상메소드를 오버라이드 선언하지 않을 경우 자식클래스도 추상클래스로 작성

  - 추상메소드를 만들어 주는 이유 

    >> 자식클래스에서 반드시 선언해야 되는 메소드와 작성규칙 제공 : 작업명세서

  - 추상클래스(부모)로 참조변수를 만들어 자식인스턴스의 정보 저장 >> 객체 형변환 이용
